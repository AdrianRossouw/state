<div class="source-title">
  <a href="javascript:void(0)">state.coffee.md</a>
</div>

<ul class="source-menu">
  
    
    
    <li><a href="export-static.html">export-static.coffee.md</a></li>
  
    
    
    <li><a href="index.html">index.coffee.md</a></li>
  
    
    
    <li><a href="root-state.html">root-state.coffee.md</a></li>
  
    
    
    <li><a href="state-content.html">state-content.coffee.md</a></li>
  
    
    
    <li><a href="state-event-emitter.html">state-event-emitter.coffee.md</a></li>
  
    
    
    <li><a href="state-expression.html">state-expression.coffee.md</a></li>
  
    
    
    <li><a href="state-function.html">state-function.coffee.md</a></li>
  
    
    
    <li><a href="state.html">state.coffee.md</a></li>
  
    
    
    <li><a href="transition-expression.html">transition-expression.coffee.md</a></li>
  
    
    
    <li><a href="transition.html">transition.coffee.md</a></li>
  
</ul>

<div class="source-content">
  
    
    <div class="row">
      <div class="text span5">
        
      </div>
      <div class="code span11">
        <div class='highlight'><pre>O                     = require <span class="string">'omicron'</span>
state                 = require <span class="string">'./state-function'</span>
StateEventEmitter     = <span class="literal">null</span>
StateExpression       = <span class="literal">null</span>
TransitionExpression  = <span class="literal">null</span>

{ STATE_ATTRIBUTES, TRAVERSAL_FLAGS } = state

module.exports =</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h2><a href="#state">State</a></h2>
<p>A <strong>state</strong> defines a subset of behavior for its <strong>owner</strong> object. Each <code>State</code>
holds a reference to a <code>superstate</code>, from which it may inherit more generic
behavior, forming a <em>state tree</em> rooted by a single <code>RootState</code>.</p>
<p>The owner’s <code>RootState</code> designates exactly one of the <code>State</code>s in its tree as
its <code>current</code> state. This reference may be <strong>transitioned</strong> to a different
<code>State</code> in the tree, causing the owner’s projected behavior to change.</p>
<p>An owner and its tree of <code>State</code>s are also heritable along the owner’s
prototype chain. Inheritors of a stateful prototype effectively possess all of
the prototype’s <code>State</code>s, but each inheritor can adopt its own <code>current</code> state
and instigate transitions independently of the prototype.</p>
<blockquote>
<p><a href="/api/#state">State</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>

  { memoizeProtostates, useDispatchTables } = state.options

  { env, NIL, isArray, isEmpty, has, hasOwn } = O
  { assign, edit, delta, clone, lookup, flatten } = O</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Bit field constants will be used extensively throughout the class’s constructor
and methods, so make them available as free variables.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  {
    INCIPIENT, ATOMIC, DESTROYED
    VIRTUAL
    MUTABLE, FINITE, STATIC, IMMUTABLE
    INITIAL, CONCLUSIVE, FINAL
    ABSTRACT, CONCRETE, DEFAULT
    REFLECTIVE
    HISTORY, RETAINED, SHALLOW
    CONCURRENT
    NORMAL
  } =
      assign <span class="keyword">this</span>, STATE_ATTRIBUTES</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>For methods that query related states, the default behavior is to recurse
through substates, superstates, and protostates.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  { VIA_NONE, VIA_SUB, VIA_SUPER, VIA_PROTO, VIA_ALL } =
      assign <span class="keyword">this</span>, TRAVERSAL_FLAGS</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Precompute certain useful attribute combinations.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  MUTABLE_OR_FINITE     = MUTABLE | FINITE
  ABSTRACT_OR_CONCRETE  = ABSTRACT | CONCRETE
  INCIPIENT_OR_VIRTUAL  = INCIPIENT | VIRTUAL
  INCIPIENT_OR_MUTABLE  = INCIPIENT | MUTABLE</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>A bit mask indicates the attributes that can be inherited via protostates.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  PROTO_HERITABLE_ATTRIBUTES =
    MUTABLE     |  FINITE      |  STATIC     |  IMMUTABLE  |
    INITIAL     |  CONCLUSIVE  |  FINAL      |
    ABSTRACT    |  CONCRETE    |  DEFAULT    |
    REFLECTIVE  |
    HISTORY     |  RETAINED    |  SHALLOW    |
    CONCURRENT  |
    NORMAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--supporting-classes">Supporting classes</a></h3>
<p>These are keyed here as a placeholder, and will be valued with a forward import
at the end of this class definition.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  Expression: <span class="literal">null</span>
  Content: <span class="literal">null</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--constructor">Constructor</a></h3>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  constructor: ( base, <span class="property">@name</span>, expression ) -&gt;</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>The <code>base</code> argument can specify either a <code>superstate</code> from which to inherit,
or an <code>owner</code> for which to act as a new <code>root</code> state.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> base <span class="keyword">instanceof</span> State
    <span class="keyword">then</span> superstate = base; root = superstate.root; owner = root.owner
    <span class="keyword">else</span> superstate = <span class="literal">null</span>; root = <span class="keyword">this</span>; owner = base

    <span class="property">@owner</span> = owner
    <span class="property">@root</span> = root
    <span class="property">@superstate</span> = superstate
    <span class="property">@protostate</span> = protostate = <span class="property">@getProtostate</span>() <span class="keyword">or</span> <span class="literal">null</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Attribute inheritance masking</h6>
<p>Explicitly defined <em>literal</em> attributes for <code>this</code> state are encoded as a bit
field integer within <code>expression</code>, and then superimposed atop the <em>inherited</em>
attribute values acquired from <code>this</code> state’s superstate and protostate.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    attributes = expression?.attributes <span class="keyword">or</span> NORMAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>The <code>mutable</code> and <code>finite</code> attributes can be inherited from the superstate
straight away.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> superstate?
      superAttr = superstate.attributes
      attributes |= superAttr &amp; MUTABLE_OR_FINITE</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>A subset of the attributes may be inherited from protostates.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> protostate?
      protoAttr = protostate.attributes &amp; PROTO_HERITABLE_ATTRIBUTES</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Literal <code>concrete</code> forcibly contradicts literal <code>abstract</code>; if a bad production
includes both attributes, negate <code>abstract</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      attributes &amp;= ~ABSTRACT <span class="keyword">if</span> attributes &amp; CONCRETE</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Literal <code>abstract</code> may override inherited <code>concrete</code>, and vice versa, so filter
those attributes out of the protostate before inheriting.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> attributes &amp; ABSTRACT_OR_CONCRETE
        protoAttr &amp;= ~ABSTRACT_OR_CONCRETE
      attributes |= protoAttr</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If at this point the state is not <code>abstract</code>, then <code>concrete</code> must be imposed.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    attributes |= CONCRETE <span class="keyword">if</span> ~attributes &amp; ABSTRACT</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Literal or inherited <code>immutable</code> contradicts <code>mutable</code> absolutely, and implies
<code>finite</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    attributes |= ( superAttr | protoAttr ) &amp; IMMUTABLE
    <span class="keyword">if</span> attributes &amp; IMMUTABLE
      attributes = attributes &amp; ~MUTABLE | FINITE

    <span class="property">@attributes</span> = attributes</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Offloaded initialization</h6>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@initialize</span> expression <span class="keyword">unless</span> attributes &amp; VIRTUAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Additional property assignments for easy viewing in the inspector.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> env.debug
      @[<span class="string">' &lt;path&gt;'</span>]       = <span class="property">@path</span>()
      @[<span class="string">'&lt;attributes&gt;'</span>]  = StateExpression.decodeAttributes attributes</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--private">Private functions</a></h3>
<h4><a href="#state--private--create-dispatcher">createDispatcher</a></h4>
<p>For each method defined in any of the owner’s states, a <strong>dispatcher</strong> must be
created and assigned on the owner itself at the <code>methodName</code> key. Calls to
<code>owner.methodName</code> are then delegated by the dispatcher to the owner’s current
state, from which the appropriate implementation for the method will be located
and applied, and its result returned back to the original caller.</p>
<p>When <code>addMethod</code> is called, if an identically named method is already present
on the owner, that function is added as a method of the owner’s root state. In
this way the owner’s original implementation remains accessible as the “default
behavior” should no current or active state contain an implementation for that
method.</p>
<p>Stateful methods are applied in the context of the <code>State</code> to which they
belong, or, if a method is inherited from a protostate, the context will be the
corresponding virtual state in the local state tree. For methods relocated to
the root state as described above, however, the context appropriately remains
bound to the owner object.</p>
<blockquote>
<p><a href="/docs/#concepts--methods--dispatchers">Dispatchers</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  createDispatcher = <span class="keyword">do</span> -&gt;
    <span class="function"><span class="title">toString</span></span> = -&gt; <span class="string">"[dispatcher]"</span>
    ( accessorName, methodName, original ) -&gt;
      <span class="function"><span class="title">dispatcher</span></span> = -&gt; @[ accessorName ]().apply methodName, arguments
      dispatcher.isDispatcher = <span class="literal">yes</span>
      dispatcher.toString = toString <span class="keyword">if</span> env.debug
      dispatcher.original = original <span class="keyword">if</span> original
      dispatcher</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--essential-methods">Essential methods</a></h3>
<h4><a href="#state--prototype--initialize">initialize</a></h4>
<p>Builds out the state’s members based on the expression provided.</p>
<blockquote>
<p>See also:
<code>Constructor</code></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  initialize: ( expression ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">if</span> attributes &amp; VIRTUAL

    <span class="property">@attributes</span> |= INCIPIENT
    <span class="property">@realize</span> expression
    <span class="property">@attributes</span> &amp;= ~INCIPIENT
    <span class="property">@emit</span> <span class="string">'construct'</span>, expression, VIA_PROTO
    <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--realize">realize</a></h4>
<p>Transforms an incipient or <strong>virtual</strong> <code>State</code> into a <strong>real</strong> state.</p>
<p>Much of the initialization for <code>State</code> is offloaded from the constructor,
allowing for creation of lightweight virtual <code>State</code> instances that inherit all
of their functionality from protostates, but can also be converted at some
later time to a real <code>State</code> if necessary.</p>
<blockquote>
<p>See also:
<code>initialize</code>
<code>virtualize</code></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  realize: ( expression ) -&gt;
    { attributes, name } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">unless</span> attributes &amp; INCIPIENT_OR_VIRTUAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Propagate realization up the superstate chain if necessary, adding each newly
realized state to the <code>substates</code> collection of its real superstate.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> attributes &amp; VIRTUAL
      <span class="keyword">if</span> ss = <span class="property">@superstate</span>
        <span class="keyword">do</span> ss.realize <span class="keyword">if</span> ss.attributes &amp; VIRTUAL
        substates = ss._.substates <span class="keyword">or</span> = {}
        <span class="keyword">do</span> substates[ name ].destroy <span class="keyword">if</span> substates[ name ]
        substates[ name ] = <span class="keyword">this</span>
      <span class="property">@attributes</span> &amp;= ~VIRTUAL

    <span class="property">@_</span> <span class="keyword">or</span> = <span class="keyword">new</span> <span class="property">@Content</span>
    <span class="property">@mutate</span> expression <span class="keyword">if</span> expression?</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Realizing a root state requires that, for each of the owner’s own methods, if
there exists at least one stateful implementation of that method located higher
in the owner’s prototype chain, then the owner’s implementation of that method
must be copied into the root, where it defines the owner’s default behavior.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> <span class="keyword">this</span> <span class="keyword">is</span> <span class="property">@root</span>
      <span class="keyword">for</span> own key, method <span class="keyword">of</span> <span class="property">@owner</span> <span class="keyword">when</span> key <span class="keyword">isnt</span> <span class="string">'constructor'</span> <span class="keyword">and</span>
          <span class="keyword">typeof</span> method <span class="keyword">is</span> <span class="string">'function'</span> <span class="keyword">and</span> <span class="keyword">not</span> method.isDispatcher <span class="keyword">and</span>
          <span class="property">@method</span> key, VIA_PROTO
        <span class="property">@addMethod</span> key, method

    <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--virtualize">virtualize</a></h4>
<p>Creates, if necessary, a virtualized <strong>epistate</strong> of <code>this</code> protostate within
the state tree to which <code>inheritor</code> belongs, and also creates as many virtual
ancestor superstates as necessary to reach a real <code>State</code> within that tree.</p>
<p>Returns the state on <code>inheritor</code>’s state tree for which <code>this</code> is a protostate.
This will be the newly created virtual state, unless virtualization was
unnecessary, in which case it will be the extant real epistate of <code>this</code>.</p>
<blockquote>
<p><a href="/docs/#concepts--inheritance--protostates">Protostates</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  virtualize: ( inheritor ) -&gt;</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Verify that <code>inheritor</code>’s owner does indeed inherit from the owner of <code>this</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">return</span> <span class="literal">null</span> <span class="keyword">unless</span> inheritor <span class="keyword">instanceof</span> State <span class="keyword">and</span>
      <span class="property">@owner</span>.isPrototypeOf inheritor.owner</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Get the <code>derivation</code> list for <code>this</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">return</span> <span class="literal">null</span> <span class="keyword">unless</span> ( derivation = <span class="property">@derivation</span> <span class="literal">yes</span> ).length</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Traverse the real states of the inheriting state tree to their furthest depth.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    i = <span class="number">0</span>; s = inheritor.root
    <span class="keyword">while</span> name = derivation[ i++ ]
      <span class="keyword">break</span> <span class="keyword">unless</span> real = s.substate name, VIA_NONE
      s = real</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If <code>derivation</code> extends beyond the inheriting state tree’s real states, then
add virtual states to it until the whole superstate chain is represented.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    expr = attributes: VIRTUAL
    <span class="keyword">while</span> name
      s = <span class="keyword">new</span> State s, name, expr
      name = derivation[ i++ ]
    s</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--destroy">destroy</a></h4>
<p>Attempts to cleanly destroy this state and all of its substates. A <code>destroy</code>
event is issued to each state after it has been destroyed.</p>
<blockquote>
<p><a href="/api/#state--methods--destroy">destroy (method)</a>
<a href="/api/#state--events--destroy">destroy (event)</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  destroy: -&gt;
    { owner, root, superstate, _ } = <span class="keyword">this</span>
    { methods, events, substates } = _ <span class="keyword">if</span> _</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If a transition is underway that involves any state other than the root, then
the state cannot be destroyed.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> transition = root._transition
      <span class="keyword">if</span> <span class="keyword">this</span> <span class="keyword">is</span> root <span class="keyword">then</span> <span class="keyword">do</span> transition.abort
      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">no</span> <span class="keyword">if</span> ( transition.origin.isIn( <span class="keyword">this</span> ) <span class="keyword">or</span>
        transition.target.isIn( <span class="keyword">this</span> ) )</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Descendant states are destroyed bottom-up.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">do</span> substate.destroy <span class="keyword">for</span> own name, substate <span class="keyword">of</span> substates</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>The final event emitted is <code>destroy</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@emit</span> <span class="string">'destroy'</span>, VIA_PROTO
    <span class="keyword">if</span> events <span class="keyword">then</span> <span class="keyword">for</span> key, event <span class="keyword">of</span> events
      <span class="keyword">do</span> event.destroy
      <span class="keyword">delete</span> events[ key ]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>When the root state is destroyed, the owner gets back its original methods, and
the corresponding dispatcher for each such method is destroyed, along with the
owner’s accessor method.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> <span class="keyword">this</span> <span class="keyword">is</span> root
      <span class="keyword">for</span> name <span class="keyword">of</span> methods <span class="keyword">when</span> dispatcher = owner[ name ]
        <span class="keyword">continue</span> <span class="keyword">unless</span> dispatcher.isDispatcher
        <span class="keyword">if</span> ownerMethod = dispatcher.original
        <span class="keyword">then</span> owner[ name ] = ownerMethod
        <span class="keyword">else</span> <span class="keyword">delete</span> owner[ name ]
      <span class="keyword">delete</span> owner[ <span class="property">@accessorName</span> ]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>A flag is set that can be observed later by anything retaining a reference to
this state (e.g. a memoization) which would be withholding it from being
garbage-collected.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@attributes</span> |= DESTROYED</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>A non-root state must remove itself from its superstate.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    superstate?.removeSubstate <span class="property">@name</span>

    <span class="literal">yes</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--expression-and-mutation">Expression and mutation</a></h3>
<h4><a href="#state--prototype--express">express</a></h4>
<p>Returns an <strong>expression</strong> of <code>this</code> state — a data structure that contains an
exported snapshot of the state’s own contents.</p>
<p>By default the returned expression is returned as a plain object; if <code>typed</code>
is truthy, the expression is a formally typed <code>StateExpression</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  express: <span class="keyword">do</span> -&gt;
    <span class="function"><span class="title">cloneCategory</span></span> = ( object ) -&gt;
      <span class="keyword">return</span> <span class="keyword">unless</span> object?
      ( out = {}; <span class="keyword">break</span> ) <span class="keyword">for</span> key <span class="keyword">of</span> object
      <span class="keyword">if</span> out <span class="keyword">then</span> <span class="keyword">for</span> key, value <span class="keyword">of</span> object
        out[ key ] = <span class="keyword">if</span> value <span class="keyword">and</span> <span class="keyword">typeof</span> value <span class="keyword">is</span> <span class="string">'object'</span>
        <span class="keyword">then</span> clone value
        <span class="keyword">else</span> value
      out

    <span class="function"><span class="title">cloneEvents</span></span> = ( events ) -&gt;
      <span class="keyword">return</span> <span class="keyword">unless</span> events?
      ( out = {}; <span class="keyword">break</span> ) <span class="keyword">for</span> type, emitter <span class="keyword">of</span> events <span class="keyword">when</span> emitter
      <span class="keyword">for</span> type, emitter <span class="keyword">of</span> events <span class="keyword">when</span> emitter
        out[ type ] = clone emitter.items
      out

    <span class="function"><span class="title">cloneSubstates</span></span> = ( substates, typed ) -&gt;
      <span class="keyword">return</span> <span class="keyword">unless</span> substates?
      ( out = {}; <span class="keyword">break</span> ) <span class="keyword">for</span> name <span class="keyword">of</span> substates
      <span class="keyword">for</span> name, substate <span class="keyword">of</span> substates
        out[ name ] = substate.express typed
      out

    ( typed ) -&gt;
      <span class="keyword">if</span> _ = <span class="property">@_</span> <span class="keyword">then</span> expression = edit {}, {  <span class="comment"># Why `edit`???</span>
        <span class="property">@attributes</span>
        data        : cloneCategory   _.data
        methods     : cloneCategory   _.methods
        events      : cloneEvents     _.events
        guards      : cloneCategory   _.guards
        states      : cloneSubstates  _.substates, typed
        transitions : cloneCategory   _.transitions
      }
      <span class="keyword">if</span> typed <span class="keyword">then</span> <span class="keyword">new</span> <span class="property">@Expression</span> expression <span class="keyword">else</span> expression</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--mutate">mutate</a></h4>
<p>Transactionally mutates <code>this</code> state by adding, updating, or removing items as
specified by the expression provided in <code>expr</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  mutate: <span class="keyword">do</span> -&gt;
    { NIL, isArray, isEmpty, isPlainObject, edit, diff } = O

    <span class="function"><span class="title">editEvent</span></span> = ( object, emitter ) -&gt;
      { items } = emitter
      <span class="keyword">for</span> own key, value <span class="keyword">of</span> object
        <span class="keyword">if</span> value <span class="keyword">is</span> NIL <span class="keyword">then</span> emitter.remove key
        <span class="keyword">else</span> <span class="keyword">if</span> value <span class="keyword">and</span> value <span class="keyword">isnt</span> items[ key ]
          emitter.set key, value

    ( expr ) -&gt;
      { attributes, Expression } = <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Booleans to determine whether mutation of particular categories is permissible;
all content is mutable for the special case of a state being initialized.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      incipient = attributes &amp; INCIPIENT
      <span class="keyword">return</span> <span class="keyword">if</span> <span class="keyword">not</span> incipient <span class="keyword">and</span> attributes &amp; IMMUTABLE
      mutable = incipient <span class="keyword">or</span> attributes &amp; MUTABLE

      <span class="keyword">do</span> <span class="property">@realize</span> <span class="keyword">if</span> attributes &amp; VIRTUAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Load the category collections.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      { data, methods, events, guards, substates, transitions } = <span class="property">@_</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Validate the provided state expression.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      expr = <span class="keyword">new</span> Expression expr <span class="keyword">unless</span> expr <span class="keyword">instanceof</span> Expression</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>The <code>initialize</code> method uses <code>mutate</code> for a real state’s initial build, but
with the resultant <code>mutate</code> event suppressed.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      before = <span class="property">@express</span>() <span class="keyword">unless</span> incipient</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Since <code>mutate</code> is transactional, the <code>ATOMIC</code> flag must be used to signal the
methods utilized here that add or remove content to temporarily suppress their
usual emission of a <code>mutate</code> event.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="property">@attributes</span> |= ATOMIC</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Data</h6>
<p>Data is already set up to handle differentials that contain <code>NIL</code> values.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="property">@data</span> expr.data <span class="keyword">if</span> expr.data</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Methods</h6>
<p>Methods are stored as a simple key mapping, and <code>addMethod</code> can be used both to
create an entry and to update an existing entry, without any additional
side-effects, so method expressions can simply be compared against the <code>NIL</code>
value.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> mutable <span class="keyword">then</span> <span class="keyword">for</span> own name, method <span class="keyword">of</span> expr.methods
        <span class="keyword">if</span> method <span class="keyword">isnt</span> NIL
        <span class="keyword">then</span> <span class="property">@addMethod</span> name, method
        <span class="keyword">else</span> <span class="property">@removeMethod</span> name</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Events</h6>
<p>Event listeners for a given event type might be expressed as either:</p>
<ul>
<li>a simple <code>Array</code> of items to be added;</li>
<li>a plain <code>Object</code> that maps items to specific event <code>id</code>s in the internal
emitter that should be added, updated, or deleted; or</li>
<li>an <code>Array</code> that also includes one or more such <code>Object</code>s.</li>
</ul>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> mutable <span class="keyword">then</span> <span class="keyword">for</span> own type, event <span class="keyword">of</span> expr.events
        events <span class="keyword">or</span> = <span class="property">@_</span>.events <span class="keyword">or</span> = {}
        emitter = events[ type ]
        <span class="keyword">if</span> event <span class="keyword">is</span> NIL <span class="keyword">then</span> <span class="keyword">do</span> emitter?.empty; <span class="keyword">continue</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If <code>event</code> contains items to be added, and an emitter does not already exist
for this event type, then one must be created.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>        <span class="keyword">if</span> <span class="keyword">not</span> emitter <span class="keyword">and</span> event <span class="keyword">and</span> <span class="keyword">not</span> isEmpty event
          emitter = events[ type ] = <span class="keyword">new</span> StateEventEmitter <span class="keyword">this</span>, type

        <span class="keyword">if</span> isArray event
        <span class="keyword">then</span> <span class="keyword">for</span> element <span class="keyword">in</span> event <span class="keyword">when</span> element? <span class="keyword">and</span> element <span class="keyword">isnt</span> NIL
          <span class="keyword">if</span> isPlainObject element
          <span class="keyword">then</span> editEvent element, emitter
          <span class="keyword">else</span> <span class="property">@addEvent</span> type, element
        <span class="keyword">else</span> editEvent event, emitter <span class="keyword">if</span> isPlainObject event

        <span class="keyword">unless</span> emitter.length
          <span class="keyword">do</span> emitter.destroy
          <span class="keyword">delete</span> events[ type ]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Guards</h6>
<p>Guards are stored as simple objects, and altering them causes no side-effects,
so a deep <code>edit</code> is sufficient.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> mutable <span class="keyword">and</span> expr.guards
        guards <span class="keyword">or</span> = <span class="property">@_</span>.guards <span class="keyword">or</span> = {}
        edit <span class="string">'deep'</span>, guards, expr.guards</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Substates</h6>
<p>Substates are instances of <code>State</code>, which are either created, destroyed, or
recursively updated in place, as specified by <code>expr.states</code>.</p>
<p>By default, a state is <strong>weakly immutable</strong>, in which case its <em>direct</em>
contents cannot be altered, although any of its substates may yet be mutable,
so any submutations must therefore still be applied recursively to their
corresponding substates.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">for</span> own name, stateExpr <span class="keyword">of</span> expr.states
        <span class="keyword">if</span> substates <span class="keyword">and</span> name <span class="keyword">of</span> substates
          <span class="keyword">if</span> stateExpr <span class="keyword">is</span> NIL
          <span class="keyword">then</span> <span class="property">@removeSubstate</span> name
          <span class="keyword">else</span> substates[ name ].mutate stateExpr
        <span class="keyword">else</span> <span class="property">@addSubstate</span> name, stateExpr <span class="keyword">if</span> stateExpr <span class="keyword">isnt</span> NIL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h6>Transitions</h6>
<p>Transitions, as held by a <code>State</code>, are instances of <code>TransitionExpression</code>,
which are either created, deleted, or replaced, as specified by
<code>expr.transitions</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> mutable <span class="keyword">then</span> <span class="keyword">for</span> own name, transitionExpr <span class="keyword">of</span> expr.transitions
        <span class="keyword">if</span> transitions <span class="keyword">and</span> name <span class="keyword">of</span> transitions
          <span class="keyword">if</span> transitionExpr <span class="keyword">is</span> NIL
          <span class="keyword">then</span> <span class="keyword">delete</span> transitions[ name ]
          <span class="keyword">else</span> transitions[ name ] =
            <span class="keyword">new</span> TransitionExpression transitionExpr
        <span class="keyword">else</span> <span class="property">@addTransition</span> name, transitionExpr <span class="keyword">if</span> transitionExpr <span class="keyword">isnt</span> NIL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>The transaction is complete, so clear <code>ATOMIC</code> to signal the <code>add...</code> methods
to emit individual <code>mutate</code> events as usual.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="property">@attributes</span> &amp;= ~ATOMIC</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Finally the <code>before</code> snapshot is used to acquire the <code>residue</code> of the mutation,
which is emitted as part of a <code>mutate</code> event.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">unless</span> incipient
        after = <span class="property">@express</span>()
        residue = diff before, after
        <span class="keyword">unless</span> isEmpty residue
          <span class="property">@emit</span> <span class="string">'mutate'</span>, [ expr, residue, before, after ], VIA_PROTO

      <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--attributes">Attributes</a></h3>
<p>Methods that inspect a state’s attributes.</p>
<blockquote>
<p><a href="/docs/#concepts--attributes">Attributes</a>
<a href="/api/#state--attributes">Attributes</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  isVirtual:     -&gt; !!( <span class="property">@attributes</span> &amp; VIRTUAL )
  isMutable:     -&gt; !!( <span class="property">@attributes</span> &amp; MUTABLE )
  isFinite:      -&gt; !!( <span class="property">@attributes</span> &amp; FINITE )
  isStatic:      -&gt; !!( <span class="property">@attributes</span> &amp; STATIC )
  isImmutable:   -&gt; !!( <span class="property">@attributes</span> &amp; IMMUTABLE )
  isInitial:     -&gt; !!( <span class="property">@attributes</span> &amp; INITIAL )
  isConclusive:  -&gt; !!( <span class="property">@attributes</span> &amp; CONCLUSIVE )
  isFinal:       -&gt; !!( <span class="property">@attributes</span> &amp; FINAL )
  isAbstract:    -&gt; !!( <span class="property">@attributes</span> &amp; ABSTRACT )
  isConcrete:    -&gt; !!( <span class="property">@attributes</span> &amp; CONCRETE )
  isDefault:     -&gt; !!( <span class="property">@attributes</span> &amp; DEFAULT )
  isReflective:  -&gt; !!( <span class="property">@attributes</span> &amp; REFLECTIVE )
  hasHistory:    -&gt; !!( <span class="property">@attributes</span> &amp; HISTORY )
  isRetained:    -&gt; !!( <span class="property">@attributes</span> &amp; RETAINED )
  isShallow:     -&gt; !!( <span class="property">@attributes</span> &amp; SHALLOW )
  isConcurrent:  -&gt; !!( <span class="property">@attributes</span> &amp; CONCURRENT )</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--object-model">Object model</a></h3>
<h4><a href="#state--prototype--derivation">derivation</a></h4>
<p>Returns a <code>State</code> array of this state’s superstate chain, starting after the
root state and ending at <code>this</code>. If <code>byName</code> is set to <code>true</code>, a string array
of the states’ names is returned instead.</p>
<blockquote>
<p><a href="/api/#state--methods--derivation">derivation</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  derivation: ( byName ) -&gt;
    results = []; ss = <span class="keyword">this</span>; <span class="keyword">while</span> ( s = ss ) <span class="keyword">and</span> ss = s.superstate
      results.push <span class="keyword">if</span> byName <span class="keyword">then</span> s.name <span class="keyword">or</span> <span class="string">''</span> <span class="keyword">else</span> s
    results.reverse()</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--path">path</a></h4>
<p>Returns this state’s fully qualified name.</p>
<p><em>Alias:</em> <strong>toString</strong></p>
<blockquote>
<p><a href="/api/#state--methods--path">path</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  path: -&gt; <span class="property">@derivation</span>( <span class="literal">yes</span> ).join <span class="string">'.'</span>
  toString: @::path</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--depth">depth</a></h4>
<p>Returns the number of superstates this state has. The root state returns <code>0</code>,
its immediate substates return <code>1</code>, etc.</p>
<blockquote>
<p><a href="/api/#state--methods--depth">depth</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  depth: -&gt;
    n = <span class="number">0</span>; s = <span class="keyword">this</span>
    n += <span class="number">1</span> <span class="keyword">while</span> s = s.superstate
    n</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--common">common</a></h4>
<p>Returns the least common ancestor of <code>this</code> and <code>other</code>. If <code>this</code> is itself an
ancestor of <code>other</code>, or vice versa, then that ancestor is returned.</p>
<blockquote>
<p><a href="/api/#state--methods--common">common</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  common: ( other ) -&gt;
    other = <span class="property">@query</span> other <span class="keyword">unless</span> other <span class="keyword">instanceof</span> State
    <span class="keyword">if</span> <span class="property">@depth</span>() &gt; other.depth() <span class="keyword">then</span> s = other; other = <span class="keyword">this</span> <span class="keyword">else</span> s = <span class="keyword">this</span>
    <span class="keyword">while</span> s
      <span class="keyword">return</span> s <span class="keyword">if</span> s <span class="keyword">is</span> other <span class="keyword">or</span> s.isSuperstateOf other
      s = s.superstate
    <span class="literal">null</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--is">is</a></h4>
<p>Determines whether <code>this</code> is <code>other</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  <span class="keyword">is</span>: ( other ) -&gt;
    other = <span class="property">@query</span> other <span class="keyword">unless</span> other <span class="keyword">instanceof</span> State
    other <span class="keyword">is</span> <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--isIn">isIn</a></h4>
<p>Determines whether <code>this</code> is or is a substate of <code>other</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  isIn: ( other ) -&gt;
    other = <span class="property">@query</span> other <span class="keyword">unless</span> other <span class="keyword">instanceof</span> State
    other <span class="keyword">is</span> <span class="keyword">this</span> <span class="keyword">or</span> other.isSuperstateOf <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--hasSubstate">hasSubstate</a></h4>
<p>Determines whether <code>this</code> is or is a superstate of <code>other</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  hasSubstate: ( other ) -&gt;
    other = <span class="property">@query</span> other <span class="keyword">unless</span> other <span class="keyword">instanceof</span> State
    other <span class="keyword">is</span> <span class="keyword">this</span> <span class="keyword">or</span> <span class="property">@isSuperstateOf</span> other</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--isSuperstateOf">isSuperstateOf</a></h4>
<p>Determines whether <code>this</code> is a superstate of <code>other</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  isSuperstateOf: ( other ) -&gt;
    other = <span class="property">@query</span> other <span class="keyword">unless</span> other <span class="keyword">instanceof</span> State
    <span class="keyword">if</span> superstate = other.superstate
      <span class="keyword">this</span> <span class="keyword">is</span> superstate <span class="keyword">or</span> <span class="property">@isSuperstateOf</span> superstate
    <span class="keyword">else</span> <span class="literal">no</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--get-protostate">getProtostate</a></h4>
<blockquote>
<p><a href="/api/#state--methods--get-protostate">getProtostate</a></p>
</blockquote>
<p>Returns <code>this</code> state’s <strong>protostate</strong>, the <code>State</code> that both:</p>
<ol>
<li>belongs to the nearest possible prototype of <code>@owner</code>; and</li>
<li>is taxonomically analogous to <code>this</code>, the inheriting <strong>epistate</strong>.</li>
</ol>
<p>If the owner does not share an analogous state tree with its immediate
prototype, or if that prototype’s tree does not contain a <code>State</code> analogous to
<code>this</code>, then the search is iterated up the owner’s prototype chain.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  getProtostate: -&gt;
    { getPrototypeOf } = O
    { owner, root } = <span class="keyword">this</span>
    { accessorName } = root
    path = <span class="property">@path</span>()</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Walk up the prototype chain, and, starting at each prototype’s root state, use
<code>this</code> state’s <code>path</code> to locate the nearest analogous <code>protostate</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    prototype = getPrototypeOf owner
    <span class="keyword">while</span> prototype
      <span class="keyword">if</span> protostate = prototype[ accessorName ]? path, VIA_NONE
        <span class="keyword">return</span> protostate
      prototype = getPrototypeOf prototype
    <span class="literal">null</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--is-protostate-of">isProtostateOf</a></h4>
<p>Determines whether <code>this</code> is a state analogous to <code>state</code> on any object in the
prototype chain of <code>state</code>’s owner.</p>
<blockquote>
<p><a href="/api/#state--methods--is-protostate-of">isProtostateOf</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  isProtostateOf: ( other ) -&gt;
    other = <span class="property">@query</span> other <span class="keyword">unless</span> other <span class="keyword">instanceof</span> State
    <span class="keyword">if</span> protostate = other.protostate
      <span class="keyword">this</span> <span class="keyword">is</span> protostate <span class="keyword">or</span> <span class="property">@isProtostateOf</span> protostate
    <span class="keyword">else</span> <span class="literal">no</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--default-substate">defaultSubstate</a></h4>
<p>Returns the first substate marked <code>default</code>, or simply the first substate.
Recursion continues into the protostate only if no local substates are marked
<code>default</code>.</p>
<blockquote>
<p><a href="/api/#state--methods--default-substate">defaultSubstate</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  defaultSubstate: ( via = VIA_PROTO, first ) -&gt;
    <span class="keyword">for</span> s <span class="keyword">in</span> substates = <span class="property">@substates</span>()
      <span class="keyword">return</span> s <span class="keyword">if</span> s.attributes &amp; DEFAULT
    first <span class="keyword">or</span> substates.length <span class="keyword">and</span> first = substates[<span class="number">0</span>]
    <span class="keyword">if</span> via &amp; VIA_PROTO <span class="keyword">and</span> protostate = <span class="property">@protostate</span>
      <span class="keyword">return</span> protostate.defaultSubstate VIA_PROTO
    first</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--initial-substate">initialSubstate</a></h4>
<p>Performs a “depth-within-breadth-first” recursive search to locate the most
deeply nested <code>initial</code> state by way of the greatest <code>initial</code> descendant
state. Recursion continues into the protostate only if no local descendant
states are marked <code>initial</code>.</p>
<blockquote>
<p><a href="/api/#state--methods--initial-substate">initialSubstate</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  initialSubstate: ( via = VIA_PROTO ) -&gt;
    i = <span class="number">0</span>; queue = [ <span class="keyword">this</span> ]
    <span class="keyword">while</span> subject = queue[ i++ ]
      <span class="keyword">for</span> s <span class="keyword">in</span> substates = subject.substates VIA_PROTO
        <span class="keyword">return</span> s.initialSubstate( VIA_NONE ) <span class="keyword">or</span> s <span class="keyword">if</span> s.attributes &amp; INITIAL
        queue.push s
    <span class="keyword">if</span> via &amp; VIA_PROTO <span class="keyword">and</span> protostate = <span class="property">@protostate</span>
      <span class="keyword">return</span> protostate.initialSubstate VIA_PROTO</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--query">query</a></h4>
<p>Matches a <code>selector</code> string with the state or states it represents, evaluated
first in the context of <code>this</code>, then its substates, and then its superstates,
until all locations in the state tree have been searched for a match of
<code>selector</code>.</p>
<p>Returns the matched <code>State</code>, or an <code>Array</code> containing the set of matched
states. If a state to be tested <code>against</code> is provided, a <code>Boolean</code> is returned,
indicating whether <code>against</code> is the matched state or is included in the
matching set.</p>
<p>If no matching state is found relative to the context of <code>this</code> state, then the
query is recursed <code>via</code> the substates, superstates, and protostates of <code>this</code>,
unless otherwise directed, such that a uniquely named state can be located by
name alone from anywhere in the state tree.</p>
<blockquote>
<p><a href="/docs/#concepts--selectors">Selectors</a>
<a href="/api/#state--methods--query">query</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  query: ( selector, against, via, toBeSkipped ) -&gt;
    <span class="keyword">if</span> <span class="keyword">typeof</span> against <span class="keyword">is</span> <span class="string">'number'</span>
      toBeSkipped = via; via = against; against = <span class="literal">undefined</span>
    via = VIA_ALL <span class="keyword">unless</span> via?</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>A few exceptional cases may be resolved early.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">unless</span> selector?
      <span class="keyword">return</span> <span class="keyword">if</span> against <span class="keyword">is</span> <span class="literal">undefined</span> <span class="keyword">then</span> <span class="literal">null</span> <span class="keyword">else</span> <span class="literal">no</span>
    <span class="keyword">if</span> selector <span class="keyword">is</span> <span class="string">'.'</span>
      <span class="keyword">return</span> <span class="keyword">if</span> against <span class="keyword">is</span> <span class="literal">undefined</span> <span class="keyword">then</span> <span class="keyword">this</span> <span class="keyword">else</span> against <span class="keyword">is</span> <span class="keyword">this</span>
    <span class="keyword">if</span> selector <span class="keyword">is</span> <span class="string">''</span>
      <span class="keyword">return</span> <span class="keyword">if</span> against <span class="keyword">is</span> <span class="literal">undefined</span> <span class="keyword">then</span> <span class="property">@root</span> <span class="keyword">else</span> against <span class="keyword">is</span> <span class="property">@root</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Absolute wildcard expressions compared against the root state pass immediately.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">return</span> <span class="literal">yes</span> <span class="keyword">if</span> against <span class="keyword">and</span> against <span class="keyword">is</span> <span class="property">@root</span> <span class="keyword">and</span> <span class="regexp">/^\*+$/</span>.test selector</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Pure <code>.</code>/<code>*</code> expressions should not be recursed.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    via &amp;= ~( VIA_SUB | VIA_SUPER ) <span class="keyword">if</span> <span class="regexp">/^\.*\**$/</span>.test selector</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If <code>selector</code> is an absolute path, evaluate it from the root state as a
relative path.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> selector.charAt(<span class="number">0</span>) <span class="keyword">isnt</span> <span class="string">'.'</span>
      <span class="keyword">return</span> <span class="property">@root</span>.query <span class="string">'.'</span> + selector, against, VIA_SUB | VIA_PROTO</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>An all-<code>.</code> <code>selector</code> must have one <code>.</code> trimmed to parse correctly.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    selector = selector.replace <span class="regexp">/^(\.+)\.$/</span>, <span class="string">'$1'</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Split <code>selector</code> into tokens, consume the leading empty-string straight away,
then parse the remaining tokens. A <code>cursor</code> reference to a matching <code>State</code> in
the tree is kept, beginning with the context state (<code>this</code>), and updated as
each token is consumed.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    parts = selector.split <span class="string">'.'</span>
    i = <span class="number">0</span>; l = parts.length; cursor = <span class="keyword">this</span>
    <span class="keyword">while</span> cursor
      i += <span class="number">1</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Upon reaching the end of token stream, return the <code>State</code> currently referenced
by <code>cursor</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">return</span> ( <span class="keyword">if</span> against <span class="keyword">then</span> against <span class="keyword">is</span> cursor <span class="keyword">else</span> cursor ) <span class="keyword">if</span> i &gt;= l</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Consume a token.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      name = parts[i]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Interpret a <strong>single wildcard</strong> as any <em>immediate</em> substate of the <code>cursor</code>
state parsed thus far.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> name <span class="keyword">is</span> <span class="string">'*'</span>
        <span class="keyword">return</span> cursor.substates() <span class="keyword">unless</span> against
        <span class="keyword">return</span> <span class="literal">yes</span> <span class="keyword">if</span> cursor <span class="keyword">is</span> against.superstate
        <span class="keyword">break</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Interpret a <strong>double wildcard</strong> as any descendant state of the <code>cursor</code> state
parsed thus far.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> name <span class="keyword">is</span> <span class="string">'**'</span>
        <span class="keyword">return</span> cursor.substates <span class="literal">yes</span> <span class="keyword">unless</span> against
        <span class="keyword">return</span> <span class="literal">yes</span> <span class="keyword">if</span> cursor.isSuperstateOf against
        <span class="keyword">break</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Empty string, the product of leading/consecutive <code>.</code>s, implies <code>cursor</code>’s
superstate.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> name <span class="keyword">is</span> <span class="string">''</span> <span class="keyword">then</span> cursor = cursor.superstate</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Interpret any other token as an identifier that names a specific substate of
<code>cursor</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">else</span> <span class="keyword">if</span> next = cursor.substate name <span class="keyword">then</span> cursor = next</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If no matching substate exists, the query fails for this context.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">else</span> <span class="keyword">break</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Recursively descend the tree, breadth-first, and retry the query with a
different context.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> via &amp; VIA_SUB
      i = <span class="number">0</span>; queue = [ <span class="keyword">this</span> ]
      <span class="keyword">while</span> subject = queue[ i++ ]
        <span class="keyword">for</span> substate <span class="keyword">in</span> subject.substates <span class="literal">no</span>, <span class="literal">yes</span>
          <span class="keyword">continue</span> <span class="keyword">if</span> substate <span class="keyword">is</span> toBeSkipped
          result = substate.query selector, against, VIA_NONE
          <span class="keyword">return</span> result <span class="keyword">if</span> result
          queue.push substate</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Recursively ascend the tree and retry the query, but skip <code>this</code> subtree during
the subsequent descent, since it’s already been searched.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> via &amp; VIA_SUPER
      <span class="keyword">return</span> result <span class="keyword">if</span> result = <span class="property">@superstate</span>?.query( selector, against,
        via &amp; VIA_SUB | VIA_SUPER, <span class="keyword">this</span> <span class="keyword">if</span> via &amp; VIA_SUB )</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Retry the query on the protostate.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> via &amp; VIA_PROTO
      <span class="keyword">return</span> result <span class="keyword">if</span> result = <span class="property">@protostate</span>?.query selector, against, via</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>All possibilities exhausted; no matches exist.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">return</span> <span class="keyword">if</span> against <span class="keyword">then</span> <span class="literal">no</span> <span class="keyword">else</span> <span class="literal">null</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--dollarsign">$</a></h4>
<p>Convenience method that either aliases to <code>change</code> if passed a function for the
first argument, or aliases to <code>query</code> if passed a string — thereby mimicking
the behavior of the object’s accessor method.</p>
<blockquote>
<p>See also: <code>createAccessor</code></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  $: ( expr, args... ) -&gt;
    <span class="keyword">if</span> <span class="keyword">typeof</span> expr <span class="keyword">is</span> <span class="string">'function'</span>
      <span class="keyword">return</span> <span class="property">@change</span>.apply <span class="keyword">this</span>, [ expr ].concat args <span class="keyword">if</span> expr = expr()
    <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">typeof</span> expr <span class="keyword">is</span> <span class="string">'string'</span> <span class="keyword">and</span>
        ( match = expr.match rxTransitionArrow ) <span class="keyword">and</span>
          method = transitionArrowMethods[ match[<span class="number">1</span>] ]
      <span class="keyword">return</span> <span class="keyword">if</span> args.length
      <span class="keyword">then</span> @[ method ].apply <span class="keyword">this</span>, [ match[<span class="number">2</span>] ].concat args
      <span class="keyword">else</span> @[ method ] match[<span class="number">2</span>]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--currency">Currency</a></h3>
<p>Methods that inspect or affect the owner’s current state.</p>
<h4><a href="#state--prototype--current">current</a></h4>
<p>Gets the local state tree’s current state, which is authoritatively determined
by the root state.</p>
<blockquote>
<p><a href="/api/#state--methods--current">current</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  current: -&gt; <span class="property">@root</span>._current</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--is-current">isCurrent</a></h4>
<p>Returns a <code>Boolean</code> indicating whether <code>this</code> is the owner’s current state.</p>
<blockquote>
<p><a href="/api/#state--methods--is-current">isCurrent</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  isCurrent: -&gt; <span class="keyword">this</span> <span class="keyword">is</span> <span class="property">@current</span>()</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--is-active">isActive</a></h4>
<p>Returns a <code>Boolean</code> indicating whether <code>this</code> or one of its substates is the
owner’s current state.</p>
<blockquote>
<p><a href="/api/#state--methods--is-active">isActive</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  isActive: -&gt; <span class="keyword">this</span> <span class="keyword">is</span> ( current = <span class="property">@current</span>() ) <span class="keyword">or</span> <span class="property">@isSuperstateOf</span> current</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--change">change</a></h4>
<p>Forwards a <code>change</code> command to <code>root</code> and returns its result. Calling with no
arguments implicitly directs the root to change to <code>this</code> state.</p>
<p><em>Aliases:</em> <strong>go</strong>, <strong>be</strong></p>
<blockquote>
<p><a href="/api/#state--methods--change">change</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  change: ( target, options ) -&gt;
    ( root = <span class="property">@root</span> ).change.apply root, arguments

  go: @::change
  be: @::change</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--change-to">changeTo</a></h4>
<blockquote>
<p>Not yet implemented.</p>
</blockquote>
<p>Calls <code>change</code> without regard to a <code>target</code>’s retained internal state.</p>
<p><em>Aliases:</em> <strong>goTo</strong>, <strong>goto</strong></p>
<blockquote>
<p>See also: <a href="#state--prototype--change"><code>State::change</code></a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  changeTo: ( target, options ) -&gt;

  goTo: @::changeTo
  goto: @::goTo</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--data">Data</a></h3>
<h4><a href="#state--prototype--data">data</a></h4>
<p>Either retrieves or edits a block of data associated with this state.</p>
<p>If provided no argument, or an integer bit field, then <code>data</code> returns a copy
of the data attached to this state, including all data from inherited states,
unless specified otherwise by the <code>via</code> query flags.</p>
<p>If called with an object-typed argument, <code>data</code> edits the data held on this
state. For keys in <code>mutation</code> whose values are set to the <code>NIL</code> directive, the
matching keys in the state’s data are deleted. If the operation results in a
change to the state’s data, a <code>mutate</code> event is emitted for this state.</p>
<blockquote>
<p><a href="/docs/#concepts--data">Data</a>
<a href="/api/#state--methods--data">data</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  data: ( via = VIA_ALL ) -&gt;</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If the provided <code>via</code> argument is not a flags integer mask, and presumably an
object instead, then interpret this call as a <em>write</em> operation, and refer to
the parameter as <code>mutation</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    mutation = via <span class="keyword">if</span> via <span class="keyword">isnt</span> via &lt;&lt; <span class="number">0</span>
    <span class="keyword">if</span> mutation
      { attributes } = <span class="keyword">this</span>
      <span class="keyword">if</span> attributes &amp; INCIPIENT_OR_MUTABLE <span class="keyword">and</span> <span class="keyword">not</span> isEmpty mutation
        <span class="keyword">return</span> <span class="property">@realize</span>().data mutation <span class="keyword">if</span> attributes &amp; VIRTUAL
        residue = delta <span class="property">@_</span>.data <span class="keyword">or</span> = {}, mutation
        <span class="keyword">if</span> <span class="keyword">not</span> ( attributes &amp; ATOMIC ) <span class="keyword">and</span> residue <span class="keyword">and</span> <span class="keyword">not</span> isEmpty residue
          <span class="property">@emit</span> <span class="string">'mutate'</span>, [ mutation, residue ], VIA_PROTO
      <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Otherwise <em>read</em> and return a copy of <code>this</code> state’s <code>data</code>, including data
inherited <code>via</code> superstates and protostates, unless directed otherwise.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">else</span> clone via &amp; VIA_SUPER <span class="keyword">and</span> <span class="property">@superstate</span>?.data(),
               via &amp; VIA_PROTO <span class="keyword">and</span> <span class="property">@protostate</span>?.data VIA_PROTO,
               <span class="property">@_</span>?.data</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--has">has</a></h4>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  has: ( key, via = VIA_ALL ) -&gt;
    viaSuper = via &amp; VIA_SUPER
    viaProto = via &amp; VIA_PROTO

    !!(
      ( data = <span class="property">@_</span>?.data ) <span class="keyword">and</span> has( data, key ) <span class="keyword">or</span>
      viaProto <span class="keyword">and</span> <span class="property">@protostate</span>?.has( key, VIA_PROTO ) <span class="keyword">or</span>
      viaSuper <span class="keyword">and</span> <span class="property">@superstate</span>?.has( key, VIA_SUPER | viaProto )
    )</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--get">get</a></h4>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  get: ( key, via = VIA_ALL ) -&gt;
    viaSuper = via &amp; VIA_SUPER
    viaProto = via &amp; VIA_PROTO

    ( data = <span class="property">@_</span>?.data ) <span class="keyword">and</span> lookup( data, key ) <span class="keyword">or</span>
    viaProto <span class="keyword">and</span> <span class="property">@protostate</span>?.get( key, VIA_PROTO ) <span class="keyword">or</span>
    viaSuper <span class="keyword">and</span> <span class="property">@superstate</span>?.get( key, VIA_SUPER | viaProto )</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--let">let</a></h4>
<p>Assigns a <code>value</code> to a <code>key</code> within <code>this</code> state’s <code>data</code> storage. If no such
key already exists, it is added.</p>
<blockquote>
<p>See also: <code>set</code></p>
<p><a href="/api/#state--methods--let">let</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  <span class="reserved">let</span>: ( key, value ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; INCIPIENT_OR_MUTABLE  <span class="comment"># should warn</span>
    <span class="keyword">return</span> <span class="property">@realize</span>().<span class="reserved">let</span> key, value <span class="keyword">if</span> attributes &amp; VIRTUAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Assignment proceeds only if the <code>value</code> being written is not the same as the
<code>displaced</code> data that is being overwritten.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    data = <span class="property">@_</span>.data <span class="keyword">or</span> = {}
    <span class="keyword">if</span> value <span class="keyword">isnt</span> displaced = lookup data, key
      assign data, key, value
      assign ( mutation = {} ).data = {}, key, value
      assign ( residue = {} ).data = {}, key, displaced
      <span class="property">@emit</span> <span class="string">'mutate'</span>, [ mutation, residue ], VIA_PROTO

    value</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--set">set</a></h4>
<p>Assigns a <code>value</code> to the nearest extant <code>key</code> within the <code>data</code> storage
inherited along the superstate chain of <code>this</code>.</p>
<p>For <code>let</code> versus <code>set</code>, the notion of a property’s <strong>scope</strong> along the
superstate chain is comparable to the same at the language level for variable
bindings within functions being shadowed versus unshadowed, respectively.</p>
<blockquote>
<p><a href="/api/#state--methods--let">let</a>
<a href="/api/#state--methods--set">set</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  set: ( key, value ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; INCIPIENT_OR_MUTABLE
    <span class="keyword">do</span> <span class="property">@realize</span> <span class="keyword">if</span> attributes &amp; VIRTUAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Find the superstate that holds the inherited property and mutate it.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    s = <span class="keyword">this</span>; <span class="keyword">while</span> s
      <span class="keyword">if</span> s.attributes &amp; MUTABLE <span class="keyword">and</span> ( data = s._.data ) <span class="keyword">and</span> key <span class="keyword">of</span> data
        <span class="keyword">return</span> s.<span class="reserved">let</span> key, value
      s = s.superstate</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If no mutable property already exists along the superstate chain, then default
to a <code>let</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@let</span> key, value</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--delete">delete</a></h4>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  <span class="keyword">delete</span>: ( key ) -&gt;
    <span class="keyword">return</span> <span class="keyword">unless</span> <span class="property">@attributes</span> &amp; MUTABLE
    NIL <span class="keyword">is</span> <span class="property">@let</span> key, NIL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--methods">Methods</a></h3>
<h4><a href="#state--prototype--method">method</a></h4>
<p>Retrieves the named method for this state. Providing an optional <code>out</code> object
allows the appropriate <code>context</code> for a state-bound method to be delivered as a
property of <code>out</code>; if included, <code>context</code> is confined to the local state tree.</p>
<blockquote>
<p><a href="/api/#state--methods--method">method</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  method: ( methodName, via = VIA_ALL, out, boxed ) -&gt;
    realized = ~<span class="property">@attributes</span> &amp; VIRTUAL</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <blockquote>
<p>During the pseudo-loop block, the <code>context</code> reference should be considered
  provisional, because its potential value is in part a product of the manner
  in which its accompanying <code>method</code> was retrieved. After <code>break</code>ing out of the
  block, <code>method</code> can be type-checked and <code>context</code> may be kept or discarded as
  appropriate.</p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">loop</span> <span class="comment"># once</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>First seek the named method locally.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> realized
        method = <span class="property">@_</span>?.methods?[ methodName ]
        <span class="keyword">if</span> method? <span class="keyword">then</span> context = <span class="keyword">this</span>
        <span class="keyword">else</span> <span class="keyword">if</span> record = <span class="property">@_</span>?.__dispatch_table__?[ methodName ]
          [ method, context ] = record
        <span class="keyword">break</span> <span class="keyword">if</span> method?</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If no method is held locally, start traversing, first up the protostate chain.
If this succeeds, the provisional <code>context</code> <em>must be the epistate</em> inheriting
the method (constrast with the <code>VIA_SUPER</code> case).</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> ( viaProto = via &amp; VIA_PROTO ) <span class="keyword">and</span>
          method = <span class="property">@protostate</span>?.method methodName, VIA_PROTO, out, <span class="literal">yes</span>
        context = <span class="keyword">this</span>
        inherited = <span class="literal">yes</span>; <span class="keyword">break</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If no method is found yet, continue traversing up the superstate chain. If this
succeeds, the provisional <code>context</code> <em>must be the superstate</em> from which the
method is inherited.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> via &amp; VIA_SUPER <span class="keyword">and</span> method = <span class="property">@superstate</span>?.method \
          methodName, VIA_SUPER | viaProto, out, <span class="literal">yes</span>
        { context } = out <span class="keyword">if</span> out?
        inherited = <span class="literal">yes</span>; <span class="keyword">break</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>The method cannot be found.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      context = <span class="literal">null</span>
      <span class="keyword">break</span> <span class="comment"># always</span>

    <span class="keyword">if</span> method?</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If <code>method</code> is a function, it is not state-bound, so <code>context</code> is unnecessary.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> <span class="keyword">typeof</span> method <span class="keyword">is</span> <span class="string">'function'</span>
        context = <span class="literal">null</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Iff <code>this</code> is a realized <code>State</code>, inherited lookup results can be memoized in
the local dispatch table.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> realized <span class="keyword">and</span> inherited <span class="keyword">and</span> useDispatchTables
        table = <span class="property">@_</span>?.__dispatch_table__ <span class="keyword">or</span> = {}
        table[ methodName ] = [ method, context ]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Unbox a state-bound function unless directed otherwise.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> <span class="keyword">not</span> boxed <span class="keyword">and</span> method.type <span class="keyword">is</span> <span class="string">'state-bound-function'</span>
        method = method.fn</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Export <code>method</code> and <code>context</code> together if the <code>out</code> reference was provided.</p>
<blockquote>
<p>Callers who know that <code>method</code> will be unbound need not provide an <code>out</code>.</p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> out?
      out.method = method
      out.context = context

    method</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--method-names">methodNames</a></h4>
<p>Returns an <code>Array</code> of names of methods defined for this state.</p>
<blockquote>
<p><a href="/api/#state--methods--method-names">methodNames</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  methodNames: -&gt;
    keys methods <span class="keyword">if</span> methods = <span class="property">@_</span>?.methods</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--add-method">addMethod</a></h4>
<p>Adds a method to this state. The provided <code>fn</code> may be any of:</p>
<ol>
<li>A proper function, which will be called in the context of <code>@owner</code>;</li>
<li>A boxing of a <em>bound</em> function as prepared by <code>state.bind</code>, which will
cause the boxed function to be called in the context of either <code>this</code>
<code>State</code> or the <em>epistate</em> inheriting the method;</li>
<li>A boxing of a <em>fixed</em> function as prepared by <code>state.fix</code>, whose boxed
function will be closed over hard references to <code>this</code> as <code>autostate</code>,
and to the <em>protostate</em> of <code>this</code>, as <code>protostate</code>.</li>
</ol>
<p>If a method called <code>methodName</code> does not already exist in the state tree, then
the owner is provided a <em>dispatcher</em> to accommodate calls to the appropriate
state’s implementation of this method.</p>
<blockquote>
<p>See also: <code>state.bind</code>, <code>state.fix</code></p>
<p><a href="/api/#state--methods--add-method">addMethod</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  addMethod: ( methodName, fn ) -&gt;
    <span class="keyword">return</span> <span class="keyword">unless</span> <span class="property">@attributes</span> &amp; INCIPIENT_OR_MUTABLE</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If <code>fn</code> boxes a <em>state-fixed</em> function, then partially apply that function to
extract the actual method, closed over references to the locality of <code>this</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> <span class="keyword">typeof</span> fn <span class="keyword">is</span> <span class="string">'object'</span> <span class="keyword">and</span> fn.type <span class="keyword">is</span> <span class="string">'state-fixed-function'</span>
      fn = fn.fn <span class="keyword">this</span>, <span class="property">@protostate</span>

    <span class="keyword">unless</span> <span class="keyword">typeof</span> fn <span class="keyword">is</span> <span class="string">'function'</span> <span class="keyword">or</span> fn?.type <span class="keyword">is</span> <span class="string">'state-bound-function'</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError <span class="string">"Must supply a plain, bound, or fixed function"</span>

    { owner } = <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Skip ahead if the owner is already set up with a dispatcher for this method.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">unless</span> ( ownerMethod = owner[ methodName ] )?.isDispatcher
      { root } = <span class="keyword">this</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Create a new dispatcher method for <code>owner</code>. Its original method, if it has one,
will be retained by the dispatcher, so that if the state tree is <code>destroy</code>ed
later, the method can be reinstated on <code>owner</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      owner[ methodName ] =
        createDispatcher root.accessorName, methodName, ownerMethod</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Unless we’re adding directly to <code>root</code>, copy <code>ownerMethod</code> to <code>root</code> — which
will not have an implementation for this method. (If it did, then <code>ownerMethod</code>
would already be a dispatcher.) From the root state it can still serve as
<code>owner</code>’s default implementation, available to any of its <code>State</code>s that do not
override that method.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">if</span> ownerMethod? <span class="keyword">and</span> <span class="keyword">this</span> <span class="keyword">isnt</span> root
        methods = root._?.methods <span class="keyword">or</span> = {}
        methods[ methodName ] = ownerMethod

    methods = <span class="property">@_</span>?.methods <span class="keyword">or</span> = {}
    methods[ methodName ] = fn</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--remove-method">removeMethod</a></h4>
<p>Dissociates the named method from this state object and returns its function.</p>
<blockquote>
<p><a href="/api/#state--methods--remove-method">removeMethod</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  removeMethod: ( methodName ) -&gt;
    <span class="keyword">return</span> <span class="keyword">unless</span> <span class="property">@attributes</span> &amp; MUTABLE <span class="keyword">and</span> ( methods = <span class="property">@_</span>?.methods ) <span class="keyword">and</span>
      fn = methods[ methodName ]
    <span class="keyword">delete</span> methods[ methodName ]
    fn</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--has-method">hasMethod</a></h4>
<p>Determines whether <code>this</code> possesses or inherits a method named <code>methodName</code>.</p>
<blockquote>
<p><a href="/api/#state--methods--has-method">hasMethod</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  hasMethod: ( methodName ) -&gt;
    method = <span class="property">@method</span> methodName</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--has-own-method">hasOwnMethod</a></h4>
<p>Determines whether <code>this</code> directly possesses a method named <code>methodName</code>.</p>
<blockquote>
<p><a href="/api/#state--methods--has-own-method">hasOwnMethod</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  hasOwnMethod: ( methodName ) -&gt;
    !! <span class="property">@method</span> methodName, VIA_NONE</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--apply">apply</a></h4>
<p>Finds a state method and applies it in the appropriate context.</p>
<p>If the named method does not exist locally and cannot be inherited, then
<code>noSuchMethod</code> events are emitted, and the call returns <code>undefined</code>.</p>
<blockquote>
<p><a href="/api/#state--methods--apply">apply</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  apply: ( methodName, args ) -&gt;</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>First try to resolve the method quickly from the local dispatch table.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> record = <span class="property">@_</span>?.__dispatch_table__?[ methodName ]
      [ method, context ] = record
      method = method.fn <span class="keyword">if</span> method?.type <span class="keyword">is</span> <span class="string">'state-bound-function'</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Resort to a proper lookup if the fast way turns up nothing.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">unless</span> method?
      <span class="keyword">if</span> method = <span class="property">@method</span> methodName, VIA_ALL, out = {}
        { context } = out</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Bail out gracefully if the method definitively cannot be resolved.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>      <span class="keyword">else</span>
        <span class="property">@emit</span> <span class="string">'noSuchMethod'</span>, [ methodName, args ]
        <span class="property">@emit</span> <span class="string">'noSuchMethod:'</span> + methodName, args
        <span class="keyword">return</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If at this point a <code>context</code> is provided, this means that <code>method</code> is a
state-bound function, and <code>context</code> will be the appropriately bound <code>State</code>. If
no <code>context</code> exists, this means that <code>method</code> is a typical non-state-bound
function, which is meant to be invoked in the usual fashion, just as if it were
called directly as a method of <code>this</code> state’s <code>owner</code>.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    method.apply context <span class="keyword">or</span> <span class="property">@owner</span>, args</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--call">call</a></h4>
<p>Variadic <code>apply</code>.</p>
<blockquote>
<p><a href="/api/#state--methods--call">call</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  call: ( methodName, args... ) -&gt;
    <span class="property">@apply</span> methodName, args</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--events">Events</a></h3>
<h4><a href="#state--prototype--event">event</a></h4>
<p>Returns a registered event listener, or the number of listeners registered, for
a given event <code>type</code>.</p>
<p>If an <code>id</code> as returned by <code>addEvent</code> is provided, the event listener associated
with that <code>id</code> is returned. If no <code>id</code> is provided, the number of event
listeners registered to <code>type</code> is returned.</p>
<blockquote>
<p><a href="/api/#state--methods--event">event</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  event: ( eventType, id ) -&gt;
    <span class="keyword">return</span> <span class="keyword">unless</span> emitter = <span class="property">@_</span>?.events?[ eventType ]
    <span class="keyword">return</span> emitter.length <span class="keyword">if</span> id <span class="keyword">is</span> <span class="literal">undefined</span>
    id = emitter.key id <span class="keyword">if</span> <span class="keyword">typeof</span> id <span class="keyword">is</span> <span class="string">'function'</span>
    emitter.get id</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--add-event">addEvent</a></h4>
<p>Binds an event listener to the specified <code>eventType</code> and returns a unique
identifier for the listener.</p>
<p><em>Alias:</em> <strong>on</strong></p>
<blockquote>
<p><a href="/api/#state--methods--add-event">addEvent</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  addEvent: ( eventType, fn, context ) -&gt;
    <span class="keyword">do</span> <span class="property">@realize</span> <span class="keyword">if</span> <span class="property">@attributes</span> &amp; VIRTUAL

    events = <span class="property">@_</span>.events <span class="keyword">or</span> = {}
    <span class="keyword">unless</span> hasOwn.call events, eventType
      events[ eventType ] = <span class="keyword">new</span> StateEventEmitter <span class="keyword">this</span>

    <span class="keyword">if</span> fn.type <span class="keyword">is</span> <span class="string">'state-fixed-function'</span>
      fn = fn.fn <span class="keyword">this</span>, <span class="property">@protostate</span>

    events[ eventType ].add fn, context

  <span class="literal">on</span>: @::addEvent</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--remove-event">removeEvent</a></h4>
<p>Unbinds the event listener with the specified <code>id</code> that was supplied by
<code>addEvent</code>.</p>
<p><em>Alias:</em> <strong>off</strong></p>
<blockquote>
<p><a href="/api/#state--methods--remove-event">removeEvent</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  removeEvent: ( eventType, id ) -&gt;
    <span class="property">@_</span>?.events?[ eventType ].remove id

  <span class="literal">off</span>: @::removeEvent</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--emit">emit</a></h4>
<p>Invokes all listeners bound to the given event type. Callbacks inherited from
superstates and protostates are also invoked, unless otherwise directed by the
traversal flags of <code>via</code>.</p>
<p>Arguments to be supplied to callbacks can be passed as an array to <code>args</code>.</p>
<p>Unless <code>context</code> is provided explicitly, a provisional <code>State</code> <code>context</code> is
determined for event callbacks that are state-bound functions. This <code>context</code>
will be either <code>this</code> or an <em>epistate</em> that inherits events from <code>this</code>.</p>
<p>Normal, unbound callbacks are invoked in the conventional context of <code>@owner</code>.</p>
<p><em>Alias:</em> <strong>trigger</strong></p>
<blockquote>
<p><a href="/api/#state--methods--emit">emit</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  emit: ( eventType, args, context, via = VIA_ALL ) -&gt;
    <span class="keyword">return</span> <span class="keyword">if</span> <span class="keyword">typeof</span> eventType <span class="keyword">isnt</span> <span class="string">'string'</span>

    <span class="keyword">if</span> <span class="keyword">typeof</span> args <span class="keyword">is</span> <span class="string">'number'</span>
      via = context; context = args; args = <span class="literal">undefined</span>
    <span class="keyword">if</span> <span class="keyword">typeof</span> context <span class="keyword">is</span> <span class="string">'number'</span>
      via = context; context = <span class="literal">undefined</span>

    args = [args] <span class="keyword">if</span> args? <span class="keyword">and</span> <span class="keyword">not</span> isArray args</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Provisional <code>context</code> is confined to the local state tree of <code>@owner</code> at the
recursive origin; i.e., <code>State</code> context is inherited transparently via
protostates, but is dynamic along the superstate chain.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@_</span>?.events?[ eventType ]?.emit args, context <span class="keyword">or</span> <span class="keyword">this</span>
    <span class="keyword">if</span> via &amp; VIA_PROTO
      <span class="property">@protostate</span>?.emit eventType, args, context <span class="keyword">or</span> <span class="keyword">this</span>, VIA_PROTO
    <span class="keyword">if</span> via &amp; VIA_SUPER
      ( ss = <span class="property">@superstate</span> )?.emit eventType, args, context <span class="keyword">or</span> ss
    <span class="keyword">return</span>

  trigger: @::emit</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--guards">Guards</a></h3>
<h4><a href="#state--prototype--guard">guard</a></h4>
<p>Gets a <strong>guard</strong> entity for this state. A guard is a value or function that
will be evaluated during a transition to determine whether an owner’s currency
will be <em>admitted</em> into or <em>released</em> from the <code>State</code> to which the guard is
applied.</p>
<p>Guards are inherited from protostates, but not from superstates.</p>
<blockquote>
<p>See also: <a href="#state--private--evaluate-guard"><code>evaluateGuard</code></a>
<a href="/api/#state--methods--guard">guard</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  guard: ( guardType ) -&gt;
    <span class="keyword">if</span> guard = <span class="property">@_</span>?.guards?[ guardType ] <span class="keyword">then</span> clone guard
    <span class="keyword">else</span> <span class="property">@protostate</span>?.guard( guardType ) <span class="keyword">or</span> <span class="literal">undefined</span></pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--add-guard">addGuard</a></h4>
<p>Adds a guard to this state, or augments an existing guard with additional
entries.</p>
<blockquote>
<p><a href="/api/#state--methods--add-guard">addGuard</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  addGuard: ( guardType, guard ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; INCIPIENT_OR_MUTABLE
    <span class="keyword">do</span> <span class="property">@realize</span> <span class="keyword">if</span> attributes &amp; VIRTUAL
    guards = <span class="property">@_</span>.guards <span class="keyword">or</span> = {}
    edit guards[ guardType ] <span class="keyword">or</span> = {}, guard</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--remove-guard">removeGuard</a></h4>
<p>Removes a guard from this state, or removes specific entries from an existing
guard.</p>
<blockquote>
<p><a href="/api/#state--methods--remove-guard">removeGuard</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  removeGuard: ( guardType, args... ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">if</span> attributes &amp; VIRTUAL
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; MUTABLE <span class="keyword">and</span> guards = <span class="property">@_</span>.guards
    <span class="keyword">return</span> <span class="literal">null</span> <span class="keyword">unless</span> guard = guards[ guardType ]
    <span class="keyword">return</span> ( guard <span class="keyword">if</span> <span class="keyword">delete</span> guards[ guardType ] ) <span class="keyword">unless</span> args.length

    <span class="keyword">for</span> key <span class="keyword">in</span> flatten args <span class="keyword">when</span> <span class="keyword">typeof</span> key <span class="keyword">is</span> <span class="string">'string'</span>
      entry = guard[ key ]
      <span class="keyword">return</span> entry <span class="keyword">if</span> <span class="keyword">delete</span> guard[ key ]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--substates">Substates</a></h3>
<h4><a href="#state--prototype--substate">substate</a></h4>
<p>Retrieves the named substate of <code>this</code> state. If no such substate exists in the
local state, any identically named substate held on a protostate will be
returned.</p>
<blockquote>
<p><a href="/api/#state--methods--substate">substate</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  substate: ( name, via = VIA_PROTO ) -&gt;</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>First scan for any virtual active substates in the local state tree.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    s = <span class="property">@root</span>._current
    <span class="keyword">while</span> s?.attributes &amp; VIRTUAL <span class="keyword">and</span> ss = s.superstate
      <span class="keyword">return</span> s <span class="keyword">if</span> ss <span class="keyword">is</span> <span class="keyword">this</span> <span class="keyword">and</span> s.name <span class="keyword">is</span> name
      s = ss</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Otherwise retrieve a real substate, either locally or from a protostate.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@_</span>?.substates?[ name ] <span class="keyword">or</span>
    via &amp; VIA_PROTO <span class="keyword">and</span> <span class="property">@protostate</span>?.substate name</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--substates">substates</a></h4>
<p>Returns an <code>Array</code> of this state’s substates. If the boolean <code>deep</code> argument is
<code>true</code>, returns a depth-first flattened array containing all of this state’s
descendant states.</p>
<blockquote>
<p><a href="/api/#state--methods--substates">substates</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  substates: ( deep, virtual ) -&gt;
    result = []</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Include virtual substates in the returned set, if any are present.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">if</span> virtual <span class="keyword">and</span> ( s = <span class="property">@root</span>._current ) <span class="keyword">and</span> s.attributes &amp; VIRTUAL <span class="keyword">and</span>
        <span class="property">@isSuperstateOf</span> s
      <span class="keyword">while</span> s <span class="keyword">and</span> s <span class="keyword">isnt</span> <span class="keyword">this</span> <span class="keyword">and</span> s.attributes &amp; VIRTUAL <span class="keyword">and</span>
          ss = s.superstate
        result.unshift s <span class="keyword">if</span> deep <span class="keyword">or</span> ss <span class="keyword">is</span> <span class="keyword">this</span>
        s = ss</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Include real substates.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">for</span> own name, substate <span class="keyword">of</span> <span class="property">@_</span>?.substates
      result.push substate
      result = result.concat substate.substates <span class="literal">yes</span> <span class="keyword">if</span> deep

    result</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--add-substate">addSubstate</a></h4>
<p>Creates a state from the supplied <code>expression</code> and adds it as a substate of
this state. If a substate with the same <code>name</code> already exists, that state is
first destroyed and then displaced.</p>
<blockquote>
<p><a href="/api/#state--methods--add-substate">addSubstate</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  addSubstate: ( name, expression ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">unless</span> attributes &amp; INCIPIENT
      <span class="keyword">return</span> <span class="keyword">if</span> attributes &amp; FINITE
      <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; MUTABLE
    <span class="keyword">do</span> <span class="property">@realize</span> <span class="keyword">if</span> attributes &amp; VIRTUAL

    substates = <span class="property">@_</span>.substates <span class="keyword">or</span> = {}
    <span class="keyword">do</span> substate.destroy <span class="keyword">if</span> substate = substates[ name ]

    substate = <span class="keyword">if</span> expression <span class="keyword">instanceof</span> State
    <span class="keyword">then</span> expression.realize() <span class="keyword">if</span> expression.superstate <span class="keyword">is</span> <span class="keyword">this</span>
    <span class="keyword">else</span> <span class="keyword">new</span> State <span class="keyword">this</span>, name, expression

    <span class="keyword">return</span> <span class="literal">null</span> <span class="keyword">unless</span> substate

    substates[ name ] = substate</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--remove-substate">removeSubstate</a></h4>
<p>Removes the named substate from the local state, if possible.</p>
<blockquote>
<p><a href="/api/#state--methods--remove-substate">removeSubstate</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  removeSubstate: ( name ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">if</span> attributes &amp; VIRTUAL

    substates = <span class="property">@_</span>?.substates
    <span class="keyword">return</span> <span class="keyword">unless</span> substate = substates?[ name ]
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; MUTABLE <span class="keyword">or</span> substate?.attributes &amp; DESTROYED</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>If a transition is underway involving <code>substate</code>, the removal must fail.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="keyword">return</span> <span class="literal">no</span> <span class="keyword">if</span> ( transition = <span class="property">@root</span>._transition ) <span class="keyword">and</span> (
      substate.isSuperstateOf( transition ) <span class="keyword">or</span>
      substate <span class="keyword">is</span> transition.origin <span class="keyword">or</span> substate <span class="keyword">is</span> transition.target
    )</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <p>Currency must be evacuated before the state can be removed.</p>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>    <span class="property">@change</span> <span class="keyword">this</span>, forced: <span class="literal">yes</span> <span class="keyword">if</span> <span class="property">@root</span>._current.isIn substate

    <span class="keyword">delete</span> substates[ name ]

    substate</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3><a href="#state--transitions">Transitions</a></h3>
<p>A <code>State</code> may hold <strong>transition expressions</strong> that describe a <code>Transition</code>
involving itself or any descendant <code>State</code>.</p>
<h4><a href="#state--prototype--transition">transition</a></h4>
<p>Returns the named transition expression held on this state.</p>
<blockquote>
<p><a href="/api/#state--methods--transition">transition</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  transition: ( name ) -&gt; <span class="property">@_</span>?.transitions?[ name ]</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--transitions">transitions</a></h4>
<p>Returns an object containing all of the transition expressions defined
on this state.</p>
<blockquote>
<p><a href="/api/#state--methods--transitions">transitions</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  transitions: -&gt; clone <span class="property">@_</span>?.transitions</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--add-transition">addTransition</a></h4>
<p>Registers a transition expression to this state.</p>
<blockquote>
<p><a href="/api/#state--methods--add-transition">addTransition</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  addTransition: ( name, expression ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; INCIPIENT_OR_MUTABLE
    <span class="keyword">do</span> <span class="property">@realize</span> <span class="keyword">if</span> attributes &amp; VIRTUAL
    <span class="keyword">unless</span> expression <span class="keyword">instanceof</span> TransitionExpression
      expression = <span class="keyword">new</span> TransitionExpression expression
    transitions = <span class="property">@_</span>.transitions <span class="keyword">or</span> = {}
    transitions[ name ] = expression</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h4><a href="#state--prototype--remove-transition">removeTransition</a></h4>
<p>Removes a transition expression from this state.</p>
<blockquote>
<p><a href="/api/#state--methods--remove-transition">removeTransition</a></p>
</blockquote>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>  removeTransition: ( name ) -&gt;
    { attributes } = <span class="keyword">this</span>
    <span class="keyword">return</span> <span class="keyword">if</span> attributes &amp; VIRTUAL
    <span class="keyword">return</span> <span class="keyword">unless</span> attributes &amp; MUTABLE <span class="keyword">and</span> transitions = <span class="property">@_</span>.transitions
    transition = transitions[ name ]
    <span class="keyword">delete</span> transitions[ name ] <span class="keyword">if</span> transition
    transition</pre></div>
      </div>
    </div>
  
    
    <div class="row">
      <div class="text span5">
        <h3>Forward imports</h3>

      </div>
      <div class="code span11">
        <div class='highlight'><pre>State::Content        = require <span class="string">'./state-content'</span>
State::Expression =
StateExpression       = require <span class="string">'./state-expression'</span>
StateEventEmitter     = require <span class="string">'./state-event-emitter'</span>
TransitionExpression  = require <span class="string">'./transition-expression'</span></pre></div>
      </div>
    </div>
  
</div>